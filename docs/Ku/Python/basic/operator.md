---
layout: doc
---

# 运算符
::: tip 说明
- 下图表示运算符按照，先后顺序计算优先级由上往下。
- 类似数学中，括号优先级最高，先乘除后加减，同样适用于py              
:::
<img src="/ysf1.png" alt="图片丢失了" width="600px" height="600px">  

```python
print(2**3)  >>8   #幂运算
print(~4)    >>-5   #按位翻转运算  公式~x = -(x+1)

chengfa = 5
print(chengfa*2)  >>10  #乘法

print(10/3)       >>3.3333   #除法
print(10//3)      >>3   #除法取商整数
print(10%3)       >>1  #除法取余数
```
---
::: details 字符串的加法和乘法
```py
a = 1
b = 2
print(a+b,a*b) #这里打印结果是3，2因为a和b都是整数类型

#-------------------------------------------------------------------
# 字符串加法和乘法是拼接
c = "1"
d = "2"
e = 3
print(c+d,c*e,d*e) #这里结果是12，111,222也是字符串类型的。把c和d拼接了一起


```

:::
::: details ~x底层的逻辑算法（了解即可）
- 正数的取反  
例如，计算 ~5（5 的二进制为 0000 0101）：  
原码：0000 0101（最高位为符号位，0 表示正数，1代表负数）  
取反后：1111 1010（每一位翻转）  
补码转十进制：  
符号位为 1，说明是负数。补码取反加 1 得原码：  
1111 1010 → 取反 0000 0101 → 加 1 0000 0110（即 6），因此结果为 -6。    
- 负数的取反  
例如，计算 ~(-5)（-5 的补码为 1111 1011）：  
补码：1111 1011  
取反后：0000 0100（即 4）  
---  
- 补码存储：现代计算机中，整数以补码形式存储  
正数的补码 = 原码（如 5 的 8 位补码为 0000 0101）。  
负数的补码 = 对应正数原码取反加 1（如 -5 的 8 位补码为 1111 1011）。

:::
::: tip 与、或、异或运算
- 下面的运算都是把数字转换为二进制来转换的
- 对于位数不同的二进制把较短的前面高位补0，对齐后上下运算取值

:::
```python
#· 与运算
a = 5                   # 二进制是  1 0 1
b = 3                   # 二进制是  0 1 1
result = a & b  # 结果是 1（二进制   0 0 1）对比上下相同才为1，不同为0
#· 或运算
a = 5  # 二进制是 101
b = 3  # 二进制是 011
result = a | b  # 结果是 7（二进制 111） 只要任意有1则是1
#· 异或运算
a = 5  # 二进制是 101
b = 3  # 二进制是 011
result = a ^ b  # 结果是 6（二进制 110）  不同则为1，相同则为0。
#左移
a = 2  # 二进制是 10
result = a << 1  # 结果是 4（二进制 100）  乘以2的1次方
#右移
a = 16  # 二进制是 1000
result = a >> 2  # 结果是 4（二进制 100）  除以2的2次方

```

::: warning 比较运算、逻辑运算、成员运算
- 结果返回bool类型
:::

```python{1,13,27}
 #比较运算    
x = 10
y = 5

print(x > y)    # True  10大于5
print(x < y)    # False 10小于5
print(x >= y)   # True  10大于等于5
print(x <= y)   # False 10小于等于5
print(x == y)   # False 10不等于5
print(x != y)   # True  10和5不相等

#----------------------------------------------------------------------
#逻辑运算
p = True
q = False

# and：全为True才True
print(p and q)  # False 

# or：有一个True就True
print(p or q)   # True  

# not：取反
print(not q)    # True  

#----------------------------------------------------------------------
#成员运算
my_list = [1, 3, 5, 7]
my_str = "hello"

print(3 in my_list)     # True  3在列表里
print(2 in my_list)     # False 2不在列表里
print('h' in my_str)    # True  'h'在字符串里
print('x' not in my_str)# True  'x'不在字符串里

```
::: info 赋值运算符
- 高效率写代码

:::

```python
# 基础赋值 = 
num = 20  

# 复合赋值（以 += 为例，其他同理）
num += 5   # 等价于 num = num + 5 →25
print(num)  

num *= 3   # 等价于 num = num * 3 →75
print(num)

num %= 4   # 等价于 num = num % 4 →75÷4余3 →3
print(num)


```

---

::: danger 身份运算符
- 这里要牵涉到，计算机运行内部的 `栈` 和 `堆` 的概念。下面有详细介绍

:::

```py
a = [1,2,3]
b = a          # b 和 a 指向同一个列表对象
c = [1,2,3]    # c 是新对象，值和a相同但内存不同  下面有详讲

print(a is b)     # True  a和b是同一个对象
print(a is c)     # False a和c是不同对象（值虽同，内存不同）
print(a is not c) # True  验证“不是同一个对象”
```
::: details 栈和堆
- 堆就是这些变量名x，y。栈是内存地址，它们的值的内存放在栈里面
```py
x = 1
y = 1
```
- 当我们定义一个变量x = 1，计算机内部，会在栈里面申请一个内存地址。这个内存地址值为1指向了变量x
- 当我们再定义一个y = 1，这个时候堆里面的x，y同时指向了，栈里面的同一个地址值1
- 身份运算符（is 或is not）本质是验证不同的变量是否指向同一个内存地址
- py会自带的IDE会先成一范围内存地址，比如整数内存地址是[-5,256]。Pycharm的是[-5,+∞]
- 在这个范围内的值，变量都会指向同一个内存地址。若超出范围，在创建一个变量时候，就会向栈里面随机生成一份新的不一样内存地址。

---
这里我打开py自带的IDE演示：  

<img src="/zhedui.png" alt="图片消失了~" white="300px" height="300px">






:::